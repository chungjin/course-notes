# Pack

- [01背包问题](#01)
    - [题目](#)
    - [基本思路](#-1)
    - [优化空间复杂度](#-2)
    - [统一格式](#-3)
    - [初始化的细节](#-4)
- [完全背包问题](#-5)
    - [题目](#-6)
    - [基本思路](#-7)
    - [O(VN)算法](#ovn)
    - [统一格式](#-8)
- [多重背包问题](#-9)
    - [题目](#-10)
    - [基本算法](#-11)
    - [转化为01背包问题](#01-1)
- [可行性问题 O(VN) 的算法](#-ovn-)
- [Leetcode相关](#leetcode)
- [Reference](#reference)


## 01背包问题

### 题目
有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。
### 基本思路
基础背包问题, 特点是，每种物品 **仅有一件**，可以选择放或不放。  
用子问题定义状态：即`F[i][v]`表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。则其状态转移方程便是：
`F[i][v] = max{F[i-1][v], F[i-1][v-c[i]]+w[i]}`, 放或者不放
伪码如下:
```python
F[0, 0..V] <-0
    for i <- 1 to N
        for v <- Ci to V
            F[i, v] <- max{F[i-1, v], F[i-1, v-Ci] + Wi}
```
这个方程非常重要，基本上所有跟背包相关的问题的方程都是由它衍生出来的。所以有必要将它详细解释一下：“将前i件物品放入容量为v的背包中”这个子问题，若只考虑第i件物品的策略（放或不放），那么就可以转化为一个只牵扯前i-1件物品的问题。如果不放第i件物品，那么问题就转化为“前i-1件物品放入容量为v的背包中”，价值为`F[i-1][v]`；如果放第i件物品，那么问题就转化为“前i-1件物品放入剩下的容量为`v-c[i]`的背包中”，此时能获得的最大价值就是`F[i-1][v-c[i]]`再加上通过放入第i件物品获得的价值w[i]。

### 优化空间复杂度
以上方法的时间和空间复杂度均为O(VN), 时间复杂度不能再优化了, 空间复杂度可以优化到O(V). 思路，从每次主循环中我们以v<-V..0的顺序计算`F[v]`，这样才能保证推`F[v]`时`F[v-c[i]]`保存的是状态`F[i-1][v-c[i]]`的值.  
伪码如下:
```python
F[0, 0..V] <-0
for i <- 1 to N
    for v <- V to Ci
        F[v] <- max{F[v], F[v-Ci] + Wi}
```
### 统一格式
```python
#F为function, C为第i件物体体积，W为第i件物体的价值
def ZeroOnePack(F, C, W)
    for v <- V to C
        F[v] <- max(F[v], F[v-C] + W)

#01背包问题的伪代码
F[0...V]<-0
    for i <- 1 to N
        ZeroOnePack(F, Ci, Wi)
```

### 初始化的细节
有的题目要求恰好装满背包时的最优解，有的题目没有要求把背包装满。它们的区别只是在初始化的时候有所不同。  
- 恰好装满背包
    初始化时，除了`F[0]`为0， 其他`F[1...,V]`均设置为`-∞`, 这样就可以保证最终得到的`F[V]`是一种恰好装满背包的最优解。
- 不要求装满背包
    初始化时，所有`F[0...,V]`均设置为`0`.  
可以这样理解：初始化的f数组事实上就是在没有任何物品可以放入背包时的合法状态。如果要求背包恰好装满，那么此时只有容量为0的背包可能被价值为0的nothing“恰好装满”，其它容量的背包均没有合法的解，属于未定义的状态，它们的值就都应该是`-∞`了。如果背包并非必须被装满，那么任何容量的背包都有一个合法解“什么都不装”，这个解的价值为0，所以初始时状态的值也就全部为0了。

## 完全背包问题
### 题目
有 N 种物品和一个容量为 V 的背包，每种物品都有 **无限件可用**。放入第 i 种物品 的费用是 Ci，价值是 Wi。求解:将哪些物品装入背包，可使这些物品的耗费的费用总 和不超过背包容量，且价值总和最大。

### 基本思路
特点是, 每件物品可以取0, 1, 2, ..., 直至取`V/ci`件。按照01背包的思路, 用`F[i,v]`表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。则其状态转移方程便是：
```python
F[i,v] = max{F[i-1, v-kCi] + kWi, o<=kCi<=v}
```
和01一样有O(NV)个状态需要求解，时间复杂度为O(NV*(V/ci))

### O(VN)算法
```python
F[0..V] <-0
for i <- 1 to N
    for v <- Ci to V
        F[v] <- max{F[v], F[v-Ci] + Wi}
```
为什么这个算法就可行呢?首先想想为什么`01背包`中要按照`v`递减的次序来循环。让`v` 递减是为了保证第`i`次循环中的状态`F[i,v]`是由状态 `F[i − 1,v − Ci]` 递推而来。
换句话说，这正是为了保证每件物品只选一次，保证在考虑“选入第 i 件物品”这件策 略时，依据的是一个绝无已经选入第`i`件物品的子结果 `F[i − 1, v − Ci]`。而现在完全背 包的特点恰是每种物品可选无限件，所以在考虑“加选一件第 i 种物品”这种策略时， 却正需要一个可能已选入第`i`种物品的子结果`F[i, v − Ci]`，所以就可以并且必须采用`v` 递增的顺序循环。这就是这个简单的程序为何成立的道理。
值得一提的是，上面的伪代码中两层for循环的次序可以颠倒。这个结论有可能会 带来算法时间常数上的优化。

### 统一格式
```python
#F为function, C为第i件物体体积，W为第i件物体的价值
def CompletePack(F, C, W)
    for v <- C to V
        F[v] <- max(F[v], F[v-C] + W)

#complete背包问题的伪代码
F[0...V]<-0
    for i <- 1 to N
        CompletePack(F, Ci, Wi)
```

## 多重背包问题
### 题目
有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i], 最多有M[i]件可用。求解将哪些物品装入背包可使价值总和最大。

### 基本算法
`F[i][v]=max{F[i-1][v-k*c[i]]+k*w[i]|0<=k<=M[i]}`  
复杂度是O(VΣM[i])

### 转化为01背包问题
方法是：将第i种物品分成若干件物品，其中每件物品有一个系数，这件物品的费用和价值均是原来的费用和价值乘以这个系数。使这些系数分别为1,2,4,...,2^(k-1),n[i]-2^k+1，且k是满足n[i]-2^k+1>0的最大整数。例如，如果n[i]为13，就将这种物品分成系数分别为1,2,4,6的四件物品。这样就将第i种物品分成了O(logM[i])种物品，将原问题转化为了复杂度为O(VΣlogM[i])的01背包问题，是很大的改进。

```python
def MultiplePack(F,C,W,M)
    if C · M ≥ V
        CompletePack(F,C,W)
        return
    k←1
    while k < M
        ZeroOnePack(kC,kW)
        M ←M − k
        k ← 2k
    #最后需要算一次M, 例如 13 = 1+2+4+6, 最后M=6, K=8, 退出循环    
    ZeroOnePack(C · M,W · M)
```

## 可行性问题 O(VN) 的算法
当问题是“每种有若干件的物品 **能否填满** 给定容量的背包”，只须考虑填满背包的 可行性，不需考虑每件物品的价值时，多重背包问题同样有`O(VN)`复杂度的算法。

下面介绍一种实现较为简单的`O(VN)`复杂度解多重背包问题的算法。它的基本思想是这样的:设`F[i,j]`表示“用了前`i`种物品填满容量为`j`的背包后，最多还剩下几个第`i`种物品可用”，如果`F[i,j] = −1`则说明这种状态不可行，若可行应满足`0 ≤ F[i,j] ≤ Mi`。
```
F[0,1...V] ← −1
F[0,0] ← 0
for i ← 1 to N
    for j ← 0 to V
        if F[i − 1][j] ≥ 0
            F [i][j] = Mi
        else
            F [i][j] = −1
    for j ← 0 to V − Ci
        if F[i][j] > 0
            F[i][j+Ci] ← max{F[i][j+Ci],F[i][j]−1}
```

## Leetcode相关
- [322 coin change](https://leetcode.com/problems/coin-change)
- [518. Coin Change 2](https://leetcode.com/problems/coin-change-2/)  

## Reference
- [背包问题九讲](https://github.com/tianyicui/pack/blob/master/V2.pdf)
