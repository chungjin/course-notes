# Ranking

要求：根据王者荣耀段位（青铜，白银，etc.，每个段位人数非常庞大），设计一个系统，
1. 每个段位显示前100名,
2. 显示全球排行榜1000名
3. 每个人可以查看自己的排名

分成读和写两个部分:
1. 对于写，有个batch概念，我们用一个框架(Kafka等消息队列)或者内存做缓冲，每1或5分钟把缓冲的数据一次性算完然后写入你的DB(Redis或Mysql都行)或内存中的数据结构，这样就把可能到`100w/qps`的更新操作变成了`1/qpm`
2. 对于读无法通过batch来优化了，我们得对两个需求分开设计，一个是查自己排名，一个是查每个段位的前1000名
  a. 对于查自己排名这个需求，本质上是查比这个分数高的分数有多少人，一个个数肯定不行。
    - 那么简单点可以维护一个桶排序的结构，即，每个分数有多少个人，然后把比这个分数高的桶人数相加就行。
    - 还有一个更优秀的做法就是用线段树(segment tree)，逻辑和桶排序类似。每个节点保存一个range, 和这个range的总人数。
  b. 对于每个段位前1000名这个需求。简单点可以每个段位维护一个优先级队列(or sorted set in Redis)，优先权通过分数和名字字典序来确定

[sorted set(0-1000)] - [sorted set(1000-2000)] - [sorted set(2000-3000)] - [sorted set(3000-all)]

优化：考虑到分数低的人会占绝大多数，并且经常不登陆，于是最低分数段并不存在in-memory里，而是在用户pull information的时候再计算。通过order by, 或扫描全表。（如果要求并不精确的话，可以直接给出估计值。比如这个分数段的总人数/2.
